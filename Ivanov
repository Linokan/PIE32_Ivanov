import pygame
import numpy as np

pygame.init()

# Размеры автомобиля для визуализации (в пикселях)
CAR_VISUAL_LENGTH = 30
CAR_VISUAL_WIDTH = 15

# Константы
PAS_CAR_LENGTH = 5  # Длина легкого автомобиля
TRUCK_CAR_LENGTH = 10 # Длина грузовика
SPEC_CAR_LENGTH = 7 # Длина спец. автомобиля
MIN_SPEED = 50  # Минимальная начальная скорость (км/ч)
MAX_SPEED = 100  # Максимальная начальная скорость (км/ч)
MIN_INTERVAL = 3  # Минимальный интервал появления автомобилей (сек)
MAX_INTERVAL = 5  # Максимальный интервал появления автомобилей (сек)
BRAKE_RATE = 5  # Скорость торможения (км/ч^2)
ACCELERATE_RATE = 2  # Скорость ускорения (км/ч^2)
TARGET_SPEED = 20  # Целевая скорость при торможении (км/ч)
ACCIDENT_DURATION = 3 # Длительность остановки после аварии

# Установка размеров окна
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
ROAD_HEIGHT = 100  # Высота однополосной дороги в пикселях
ROAD_COLOR = (50, 50, 50)  # Серый цвет для дороги
LINE_COLOR = (255, 255, 255)  # Белый цвет для разметки

# Определение размера и цвета текста
TEXT_SIZE = 20
TEXT_COLOR = (255, 255, 255)

# Загрузка шрифтов
font = pygame.font.SysFont(None, TEXT_SIZE)

# Создание изображений букв для каждого типа машины
letter_L = font.render('Л', True, TEXT_COLOR)
letter_G = font.render('Г', True, TEXT_COLOR)
letter_S = font.render('С', True, TEXT_COLOR)

# Конвертация км/ч в м/с
def kmh_to_ms(speed_kmh):
    return speed_kmh * 1000 / 3600

class Car:
    def __init__(self, initial_speed, position, color=(0, 255, 0)):
        self.initial_speed = initial_speed
        self.speed = initial_speed
        self.position = position
        self.color = color
        self.state = 'moving'  # Состояния: moving (движется), braking (тормозит), accelerating (ускоряется), stopped (остановилась)
        self.accident_duration = ACCIDENT_DURATION # время после аварии, после которого машина продолжает движение
        self.accident_time = 0 # время после аварии, счетчик

    def update(self, delta_time, leading_car=None):
        if self.state == 'braking':
            # Применяем закон торможения
            self.braking_law(delta_time)
            # Если расстояние до ведущей машины больше безопасного, переходим в состояние "движение"
            if not leading_car or self.position + self.length * 4 < leading_car.position:
                self.state = 'moving'
        elif self.state == 'accelerating':
            # Увеличиваем скорость на определенную величину (ACCELERATE_RATE)
            self.speed = min(self.initial_speed, self.speed + ACCELERATE_RATE * delta_time)  # Пример закона ускорения
            if self.speed == self.initial_speed:
                self.state = 'moving'
        elif self.state == 'moving':
            if leading_car and self.position + self.length * 4 >= leading_car.position:  # Если расстояние до впереди идущей машины меньше 2 корпусов, начинаем тормозить
                self.state = 'braking'
        elif self.state == 'stopped':
            self.accident_time += delta_time
            if self.accident_time >= self.accident_duration:
                self.state = 'moving'
                road = self.get_road_instance()
                road.remove_car(self)  # Удаляем машину из объекта Road

        self.position += self.speed * delta_time


    # Торможение
    def braking_law(self, delta_time):
        # Максимальное ускорение при торможении
        max_braking_acceleration = 5  # км/ч^2
        # Минимальная целевая скорость (20% от начальной)
        target_speed = self.initial_speed * 0.2  # км/ч

        # Если скорость больше или равна целевой, тормозим с максимальным ускорением
        if self.speed >= target_speed:
            # Уменьшаем скорость на максимальное ускорение
            self.speed = max(0, self.speed - max_braking_acceleration * delta_time)


    # Проверка столкновения автомобилей
    def check_collision(self, other_car):
        if self.position + self.length >= other_car.position and self.position <= other_car.position + other_car.length:
            self.state = 'stopped'
            other_car.state = 'stopped'
            self.speed = 0
            other_car.speed = 0

class PassengerCar(Car):
    # Легковой автомобиль
    def __init__(self, initial_speed, position):
        super().__init__(initial_speed, position, (0, 0, 255))  # Синий цвет для легкового автомобиля
        self.type = 'passenger'
        self.length = PAS_CAR_LENGTH # Длина легковушки в метрах

class Truck(Car):
    # Грузовик
    def __init__(self, initial_speed, position):
        super().__init__(initial_speed, position, (255, 0, 0))  # Красный цвет для грузовика
        self.length = TRUCK_CAR_LENGTH  # Длина грузовика в метрах
        self.type = 'truck'

class SpecialCar(Car):
    # Специальная машина (пожарная и т.д.)
    def __init__(self, initial_speed, position):
        super().__init__(initial_speed, position, (0, 255, 0))  # Зеленый цвет для специального автомобиля
        self.length = SPEC_CAR_LENGTH  # Длина специального автомобиля в метрах
        self.type = 'special'


class Road:
    def __init__(self, length):
        self.length = length
        self.cars = []
        self.time_since_last_car = 0
        self.next_car_time = np.random.uniform(MIN_INTERVAL, MAX_INTERVAL)
        self.delayed_car = None
        self.delay_time = 5  # Время задержки в секундах

    def add_car(self, car):
        if not self.cars or self.cars[-1].position >= car.length * 4:  # 4 корпуса для безопасного старта
            self.cars.append(car)

    def update(self, delta_time):
        self.time_since_last_car += delta_time
        if self.time_since_last_car >= self.next_car_time: # Проверка интервала
            car_type = np.random.choice(['passenger', 'truck', 'special']) # Выбор генерации рандомного типа автомобиля
            initial_speed = np.random.uniform(kmh_to_ms(MIN_SPEED), kmh_to_ms(MAX_SPEED)) # Генерация скорости

            if car_type == 'passenger':
                new_car = PassengerCar(initial_speed, 0)
            elif car_type == 'truck':
                new_car = Truck(initial_speed, 0)
            elif car_type == 'special':
                new_car = SpecialCar(initial_speed, 0)

            self.add_car(new_car)
            self.time_since_last_car = 0
            self.next_car_time = np.random.uniform(MIN_INTERVAL, MAX_INTERVAL)

        for i, car in enumerate(self.cars):
            leading_car = self.cars[i-1] if i > 0 else None
            car.update(delta_time, leading_car)
            for other_car in self.cars:
                if car != other_car:
                    car.check_collision(other_car)

        # Обрабатываем искусственную задержку одного автомобиля
        if self.delayed_car:
            self.delay_time -= delta_time
            if self.delay_time <= 0:
                self.delayed_car.state = 'accelerating'
                self.delayed_car = None

    def delay_random_car(self):
        if not self.delayed_car and self.cars:
            self.delayed_car = np.random.choice(self.cars)
            self.delayed_car.state = 'braking'
            self.delay_time = 5

    def remove_car(self, car):
        if car in self.cars:
            self.cars.remove(car)


screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))


def draw_road():
    road_rect = pygame.Rect(0, (SCREEN_HEIGHT - ROAD_HEIGHT) / 2, SCREEN_WIDTH, ROAD_HEIGHT)
    pygame.draw.rect(screen, ROAD_COLOR, road_rect)

    # Рисуем центральную разметку
    line_width = 5
    for x in range(0, SCREEN_WIDTH, 40):
        pygame.draw.line(screen, LINE_COLOR,
                         (x, (SCREEN_HEIGHT + line_width) / 2),
                         (x + 20, (SCREEN_HEIGHT + line_width) / 2), line_width)


def draw_car(car):
    x = car.position * SCREEN_WIDTH / 1000  # Конвертация позиции из метров в пиксели
    y = (SCREEN_HEIGHT - ROAD_HEIGHT) / 2 + (ROAD_HEIGHT - car.length * 3) / 2  # Центрируем машины на дороге
    car_rect = pygame.Rect(x, y, car.length * 6, car.length * 3)

    # Определение цвета машины в зависимости от ее состояния
    if car.state == 'braking':
        color = (0, 0, 255)  # Синий цвет при торможении
    elif car.state == 'accelerating':
        color = (255, 0, 0)  # Красный цвет при ускорении
    elif car.state == 'stopped':
        color = (0, 0, 0)  # Черный цвет при аварии
    else:
        color = (0, 255, 0)  # Зеленый цвет при обычном движении

    # Рисуем машину с контуром
    pygame.draw.rect(screen, color, car_rect.move(x - car.position * SCREEN_WIDTH / 1000, 0))
    pygame.draw.rect(screen, (0, 0, 0), car_rect.inflate(2, 2).move(x - car.position * SCREEN_WIDTH / 1000, 0), 1)

    # Отрисовка буквы в центре машины
    if isinstance(car, PassengerCar):
        screen.blit(letter_L, (car_rect.centerx - letter_L.get_width() / 2, car_rect.centery - letter_L.get_height() / 2))
    elif isinstance(car, Truck):
        screen.blit(letter_G, (car_rect.centerx - letter_G.get_width() / 2, car_rect.centery - letter_G.get_height() / 2))
    elif isinstance(car, SpecialCar):
        screen.blit(letter_S, (car_rect.centerx - letter_S.get_width() / 2, car_rect.centery - letter_S.get_height() / 2))


def update_screen(road):
    screen.fill((255, 255, 255))  # Белый фон
    draw_road()  # Рисуем дорогу
    for car in road.cars:
        draw_car(car)
    pygame.display.flip()


def main():
    clock = pygame.time.Clock()
    road = Road(length=1000)  # Длина дороги в метрах

    running = True
    while running:
        delta_time = clock.get_time() / 1000.0  # Время между кадрами в секундах

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:
                    road.delay_random_car()

        road.update(delta_time)
        update_screen(road)

        clock.tick(60)  # Ограничение до 60 кадров в секунду

    pygame.quit()

if __name__ == "__main__":
    main()
